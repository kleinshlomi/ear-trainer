<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>××™××•×Ÿ ××•×–×Ÿ</title>

  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><text y='14' font-size='14'>ğŸ¹</text></svg>">

  <style>
    body { font-family: system-ui, Arial; padding: 20px; max-width: 980px; margin: auto; }
    button { padding: 10px 14px; margin: 6px 6px 6px 0; font-size: 16px; }
    .row { margin-top: 10px; }
    .tabs { display: flex; gap: 10px; margin-bottom: 12px; flex-wrap: wrap; }
    .tab { padding: 10px 14px; border: 1px solid #aaa; border-radius: 10px; cursor: pointer; user-select: none; }
    .tab.active { font-weight: 900; }
    .panel { display: none; }
    .panel.active { display: block; }

    #status { margin-top: 12px; font-weight: 900; }
    #bigAnswer { margin-top: 12px; font-size: 54px; font-weight: 900; text-align: center; min-height: 64px; }

    .small { font-size: 13px; opacity: 0.85; line-height: 1.35; }
    kbd { padding: 2px 6px; border: 1px solid #aaa; border-radius: 6px; font-family: ui-monospace, Menlo, monospace; }
    input[type="range"] { width: 260px; }
    label { display: block; margin-top: 10px; }

    .resultPanel {
      margin-top: 12px;
      padding: 12px 14px;
      border: 1px solid #aaa;
      border-radius: 12px;
    }
    .resultGrid {
      display: flex;
      gap: 18px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
    }
    .resultItem {
      display: flex;
      gap: 10px;
      align-items: center;
      min-width: 260px;
    }
    .resultLabel { font-weight: 900; }
    .resultValue { font-weight: 900; font-size: 18px; }
    .mark {
      font-weight: 900;
      font-size: 20px;
      width: 26px;
      text-align: center;
    }
    .mark.ok { color: #0a7a0a; }
    .mark.bad { color: #b30000; }
    .mark.neutral { color: #666; }

    .unlockBar {
      padding: 12px 14px;
      border: 1px solid #aaa;
      border-radius: 12px;
      margin-bottom: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px 14px;
      align-items: center;
      justify-content: space-between;
    }
    .unlockLeft { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .badge {
      font-weight: 900;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #aaa;
    }
    .badge.ok { color: #0a7a0a; border-color: #0a7a0a; }
    .badge.bad { color: #b30000; border-color: #b30000; }

    .refRow {
      margin: 10px 0 6px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    #degreeAnswerRow { display: none; }
    .degreeRow {
      display: flex;
      direction: ltr;
      justify-content: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 6px;
    }
    .degreeRow button { min-width: 70px; }

    .statsPanel {
      margin-top: 12px;
      padding: 12px 14px;
      border: 1px solid #aaa;
      border-radius: 12px;
    }
    .statsGrid {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 20px;
      align-items: flex-start;
      justify-content: space-between;
    }
    .stat { min-width: 230px; }
    .stat b { font-weight: 900; }
    .btnDanger {
      border: 1px solid #b30000;
      color: #b30000;
      background: transparent;
      border-radius: 10px;
    }

    .miniTable {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      font-size: 13px;
    }
    .miniTable th, .miniTable td {
      border: 1px solid #ddd;
      padding: 6px 8px;
      text-align: center;
      white-space: nowrap;
    }
    .miniTable th { font-weight: 900; background: #f6f6f6; }

    #biasRow, #adaptiveRow {
      display:none;
      margin-top:8px;
      padding:8px 10px;
      border:1px dashed #aaa;
      border-radius:10px;
    }

    #playModeRow {
      display:none;
      margin-top:8px;
      padding:8px 10px;
      border:1px dashed #aaa;
      border-radius:10px;
    }
  </style>
</head>
<body>

  <h2>××™××•×Ÿ ××•×–×Ÿ</h2>

  <div class="unlockBar">
    <div class="unlockLeft">
      <button id="unlockBtn">×”×¤×¢×œ ×¡××•× ×“</button>
      <span class="badge bad" id="audioBadge">×¡××•× ×“ ×œ× ×”×•×¤×¢×œ</span>
      <span class="small" id="audioHint">×‘×˜×œ×¤×•×Ÿ ××•××œ×¥ ×œ×œ×—×•×¥ ×¤×¢× ××—×ª ×›×“×™ ×œ×˜×¢×•×Ÿ ×“×’×™××•×ª ××¨××©.</span>
    </div>
    <div class="small" id="audioProgress">×“×’×™××•×ª: 0/9</div>
  </div>

  <div class="refRow">
    <button id="refC4Btn">×¨×¤×¨× ×¡</button>
    <div class="small">×§×™×¦×•×¨: <kbd>C</kbd>/<kbd>c</kbd>/<kbd>×‘</kbd></div>
  </div>

  <div class="tabs">
    <div class="tab active" id="tabThirds">××¦×‘ 1: ×˜×¨×¦×•×ª / ×˜×¨×™××“×•×ª</div>
    <div class="tab" id="tabDegrees">××¦×‘ 2: ×“×¨×’×•×ª ×‘×¡×•×œ× ×“×•</div>
  </div>

  <div class="small">
    <kbd>Space</kbd> × ×’×Ÿ Â· <kbd>R</kbd> × ×’×Ÿ ×©×•×‘ Â· ×¨×¤×¨× ×¡: <kbd>C</kbd><br/>
    Toggle ××§×•×¨×“ ×‘×•Ö¾×–×× ×™×ª: <kbd>E</kbd>/<kbd>e</kbd>/<kbd>×§</kbd><br/>
    ××¦×‘ "× ×’×Ÿ ×“×¨×’×•×ª" ×œ×˜×¨×™××“×•×ª: <kbd id="playModeKeyHint">P</kbd> (×•××– JKL;UIO ×× ×’× ×™×)<br/>
    ×˜×¨×¦×•×ª: ××–'×•×¨ <kbd>M</kbd>/<kbd>F</kbd> Â· ××™× ×•×¨ <kbd>N</kbd>/<kbd>D</kbd><br/>
    ×˜×¨×™××“×•×ªÖ¾×“×¨×’×•×ª: 1=<kbd>J</kbd> Â· 2=<kbd>K</kbd> Â· 3=<kbd>L</kbd> Â· 4=<kbd>;</kbd> Â· 5=<kbd>U</kbd> Â· 6=<kbd>I</kbd> Â· 7=<kbd>O</kbd>
  </div>

  <hr />

  <section class="panel active" id="panelThirds">
    <h3>××¦×‘ 1</h3>

    <div class="row">
      <button id="playBtn">× ×’×Ÿ ×¨× ×“×•××œ×™</button>
      <button id="replayBtn">× ×’×Ÿ ×©×•×‘ (R)</button>
    </div>

    <div class="row" id="thirdsAnswerRow">
      <button id="majorBtn" disabled>××–'×•×¨</button>
      <button id="minorBtn" disabled>××™× ×•×¨</button>
    </div>

    <div class="row" id="degreeAnswerRow">
      <div class="small">×¢× ×” ×“×¨×’×” (Iâ€“viiÂ°):</div>
      <div class="degreeRow" id="degreeButtons"></div>
    </div>

    <label><input type="checkbox" id="asChord" /> ×œ× ×’×Ÿ ×›××§×•×¨×“ (×‘×•Ö¾×–×× ×™×ª). ×× ×œ× ××¡×•××Ÿ â€“ ×™× ×’×Ÿ ×‘××¨×¤×’'×™×•.</label>
    <label><input type="checkbox" id="randomStyle" /> ××¦×‘ ××•×˜×•××˜×™: ×‘×›×œ × ×’×™× ×” ×œ×‘×—×•×¨ ×¨× ×“×•××œ×™×ª ×‘×™×Ÿ ××§×•×¨×“ ×œ×‘×™×Ÿ ××¨×¤×’'×™×•.</label>
    <label><input type="checkbox" id="diatonicCThirdsOnly" /> ×œ×”×’×‘×™×œ ×œ×–×•×’×•×ª ×˜×¨×¦×” ××ª×•×š ×“×• ××–'×•×¨ ×‘×œ×‘×“</label>

    <label><input type="checkbox" id="triadsDegreeMode" checked /> ×‘×“×• ××–'×•×¨: ×˜×¨×™××“×•×ªÖ¾×“×¨×’×•×ª (I, ii, iii, IV, V, vi, viiÂ°)</label>
    <label><input type="checkbox" id="commonProgressions" checked /> ×˜×¨×™××“×•×ª: ××¦×‘ ××”×œ×›×™× × ×¤×•×¦×™× (××§×¨××™ ×¢× ×”×˜×™×” ×œ××”×œ×›×™× ××•×›×¨×™×)</label>

    <div id="biasRow">
      <div class="small" style="font-weight:900;">×¢×•×¦××ª ×”×˜×™×” ×œ××”×œ×›×™× × ×¤×•×¦×™×: <span id="biasPct">70%</span></div>
      <input id="biasSlider" type="range" min="0" max="100" step="5" value="70" />
      <div class="small">0% = ××§×¨××™ ×˜×”×•×¨ Â· 100% = ×›××¢×˜ ×ª××™×“ ××”×œ×›×™× × ×¤×•×¦×™×</div>
    </div>

    <label><input type="checkbox" id="adaptiveTrainer" checked /> ×˜×¨×™××“×•×ª: ××¦×‘ ××“×¤×˜×™×‘×™ (×œ×—×–×§ ×“×¨×’×•×ª ×—×œ×©×•×ª ×¢×“ ×©×”×“×™×•×§×™× ××ª×™×™×©×¨×™×)</label>

    <div id="adaptiveRow">
      <div class="small" style="font-weight:900;">×¢×•×¦××ª ××“×¤×˜×™×‘×™×•×ª: <span id="adaptivePct">70%</span></div>
      <input id="adaptiveSlider" type="range" min="0" max="100" step="5" value="70" />
      <div class="small">0% = ×›×‘×•×™ Â· 100% = ×—×™×–×•×§ ×—×–×§ ×œ×“×¨×’×•×ª ×—×œ×©×•×ª</div>
    </div>

    <!-- NEW: On-screen controls for play-mode + key selection -->
    <div id="playModeRow">
      <div class="small" style="font-weight:900; margin-bottom:6px;">
        ××¦×‘ "× ×’×Ÿ ×“×¨×’×•×ª" (×›×©×”×•× ×¤×¢×™×œ: JKL;UIO ×× ×’× ×™× ×˜×¨×™××“×•×ª ×‘××§×•× ×œ×¢× ×•×ª)
      </div>
      <button id="playModeToggleBtn">××¦×‘ × ×’×Ÿ ×“×¨×’×•×ª: ×›×‘×•×™</button>
      <button id="playModeKeyBtn">××§×© ××¦×‘: P</button>
      <div class="small" style="margin-top:6px;">
        ×§×™×¦×•×¨ ××§×œ×“×ª: ×œ×—×¥ <kbd id="playModeKeyHint2">P</kbd> ×›×“×™ ×œ×”×“×œ×™×§/×œ×›×‘×•×ª.
      </div>
    </div>

    <label>
      ×˜×•×•×— ×‘×¡×™×¡×™× (×¨×§ ×›×©××™×Ÿ ×”×’×‘×œ×•×ª): <span id="rangeLabel"></span>
      <div class="small">××•××œ×¥: ×œ×”×©××™×¨ ×‘×××¦×¢ ×›×“×™ ×©×œ× ×™×”×™×” ×’×‘×•×”/× ××•×š ××“×™.</div>
      <input id="lowNote" type="range" min="48" max="72" step="1" value="55" />
      <input id="highNote" type="range" min="48" max="72" step="1" value="67" />
    </label>

    <label><input type="checkbox" id="avoidBlackRoot" /> ×œ×”×¢×“×™×£ ×‘×¡×™×¡×™× ×¢×œ ×§×œ×™×“×™× ×œ×‘× ×™× ×‘×œ×‘×“</label>
  </section>

  <section class="panel" id="panelDegrees">
    <h3>××¦×‘ 2 (××™× ×™××œ×™)</h3>
    <div class="row">
      <button id="degPlayBtn">× ×’×Ÿ</button>
      <button id="degReplayBtn">× ×’×Ÿ ×©×•×‘</button>
    </div>
    <div class="row" id="degAnswers" style="direction:ltr; display:flex; gap:8px; flex-wrap:wrap;"></div>
  </section>

  <div id="status">××•×›×Ÿ.</div>

  <div class="resultPanel">
    <div class="resultGrid">
      <div class="resultItem">
        <span class="resultLabel">××” ×¢× ×™×ª:</span>
        <span class="resultValue" id="userAnswerText">â€”</span>
        <span class="mark neutral" id="userAnswerMark">â€”</span>
      </div>
      <div class="resultItem">
        <span class="resultLabel">×”×ª×©×•×‘×” ×”× ×›×•× ×”:</span>
        <span class="resultValue" id="correctAnswerText">â€”</span>
      </div>
    </div>
  </div>

  <div id="bigAnswer"></div>

  <div class="statsPanel">
    <div class="statsGrid">
      <div class="stat">×“×™×•×§ ×›×œ×œ×™: <b><span id="accAll">â€”</span></b></div>
      <div class="stat">×¨×¦×£ × ×›×•×Ÿ: <b><span id="streakNow">0</span></b> Â· ×©×™×: <b><span id="streakBest">0</span></b></div>
      <div class="stat">×××•×¦×¢ ×–××Ÿ ×ª×’×•×‘×”: <b><span id="avgTimeAll">â€”</span></b></div>
      <div class="stat">×“×™×•×§ ×˜×¨×¦×•×ª: <b><span id="accThirds">â€”</span></b></div>
      <div class="stat">×“×™×•×§ ×˜×¨×™××“×•×ªÖ¾×“×¨×’×•×ª: <b><span id="accTriads">â€”</span></b></div>
      <div class="stat"><button class="btnDanger" id="resetStatsBtn">××™×¤×•×¡ ×¡×˜×˜×™×¡×˜×™×§×”</button></div>
    </div>

    <div class="small" style="margin-top:10px; font-weight:900;">×˜×¨×™××“×•×ªÖ¾×“×¨×’×•×ª: ×¡×˜×˜×™×¡×˜×™×§×” ×œ×¤×™ ×“×¨×’×”</div>
    <table class="miniTable">
      <thead><tr><th>×“×¨×’×”</th><th>×¡×™××•×Ÿ</th><th>× ×©××œ</th><th>× ×›×•×Ÿ</th><th>×“×™×•×§</th></tr></thead>
      <tbody id="triadDegreeStatsBody"></tbody>
    </table>
  </div>

<script>
/* ===================== AUDIO ===================== */
let audioCtx = null;
let sampleBuffers = new Map();
let sampleLoadPromise = null;

const unlockBtn = document.getElementById("unlockBtn");
const audioBadge = document.getElementById("audioBadge");
const audioProgress = document.getElementById("audioProgress");
const audioHint = document.getElementById("audioHint");

function getCtx() {
  if (!audioCtx) {
    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AC();
  }
  return audioCtx;
}
function assetUrl(relPath) {
  const baseDir = new URL("./", window.location.href);
  return new URL(relPath, baseDir).toString();
}
const SAMPLE_MAP = [
  { midi: 48, file: "assets/piano/C3.mp3"  },
  { midi: 51, file: "assets/piano/Ds3.mp3" },
  { midi: 54, file: "assets/piano/Fs3.mp3" },
  { midi: 57, file: "assets/piano/A3.mp3"  },
  { midi: 60, file: "assets/piano/C4.mp3"  },
  { midi: 63, file: "assets/piano/Ds4.mp3" },
  { midi: 66, file: "assets/piano/Fs4.mp3" },
  { midi: 69, file: "assets/piano/A4.mp3"  },
  { midi: 72, file: "assets/piano/C5.mp3"  },
];

function setAudioBadgeOk(msg) {
  audioBadge.textContent = msg;
  audioBadge.classList.remove("bad");
  audioBadge.classList.add("ok");
}
function setAudioBadgeBad(msg) {
  audioBadge.textContent = msg;
  audioBadge.classList.remove("ok");
  audioBadge.classList.add("bad");
}

async function ensureAudioReady() {
  const ctx = getCtx();
  if (ctx.state === "suspended") await ctx.resume();
  if (!sampleLoadPromise) sampleLoadPromise = loadAllSamplesBestEffort();
  await sampleLoadPromise;
  return ctx;
}

async function fetchDecode(file) {
  const ctx = getCtx();
  const url = assetUrl(file);
  const res = await fetch(url, { cache: "no-cache" });
  if (!res.ok) throw new Error("Sample fetch failed: " + res.status + " for " + url);
  const arr = await res.arrayBuffer();
  return await ctx.decodeAudioData(arr);
}

async function loadAllSamplesBestEffort() {
  let loaded = 0;
  audioProgress.textContent = "×“×’×™××•×ª: 0/" + SAMPLE_MAP.length;
  for (const s of SAMPLE_MAP) {
    try {
      const buf = await fetchDecode(s.file);
      sampleBuffers.set(s.midi, buf);
      loaded += 1;
      audioProgress.textContent = "×“×’×™××•×ª: " + loaded + "/" + SAMPLE_MAP.length;
    } catch (err) { console.warn(err); }
  }
  if (loaded === 0) {
    setAudioBadgeBad("×©×’×™××” ×‘×˜×¢×™× ×ª ×¡××•× ×“");
    audioHint.textContent = "0 ×“×’×™××•×ª × ×˜×¢× ×•. ×‘×“×•×§ assets/piano.";
    throw new Error("No samples loaded.");
  }
  setAudioBadgeOk("×¡××•× ×“ ×”×•×¤×¢×œ");
  audioHint.textContent = "×”×›×•×œ × ×˜×¢×Ÿ (××• ×—×œ×§×™×ª). ××¤×©×¨ ×œ×”×ª×××Ÿ.";
}

function availableSampleMidis() { return Array.from(sampleBuffers.keys()).sort((a,b)=>a-b); }
function nearestSampleMidi(targetMidi) {
  const mids = availableSampleMidis();
  let best = mids[0];
  let bestDist = Math.abs(targetMidi - best);
  for (const m of mids) {
    const d = Math.abs(targetMidi - m);
    if (d < bestDist) { bestDist = d; best = m; }
  }
  return best;
}
function rateForMidi(targetMidi, baseMidi) { return Math.pow(2, (targetMidi - baseMidi) / 12); }

function playBufferNote(ctx, buf, rate, startTime, durSec, gainVal) {
  const src = ctx.createBufferSource();
  src.buffer = buf;
  src.playbackRate.setValueAtTime(rate, startTime);
  const g = ctx.createGain();
  g.gain.setValueAtTime(0.0001, startTime);
  g.gain.linearRampToValueAtTime(gainVal, startTime + 0.01);
  g.gain.linearRampToValueAtTime(0.0001, startTime + durSec);
  src.connect(g).connect(ctx.destination);
  src.start(startTime);
  src.stop(startTime + durSec + 0.05);
}

async function playSingleMidi(midi) {
  const ctx = await ensureAudioReady();
  const base = nearestSampleMidi(midi);
  const buf = sampleBuffers.get(base);
  if (!buf) return;
  const now = ctx.currentTime + 0.03;
  playBufferNote(ctx, buf, rateForMidi(midi, base), now, 0.9, 0.9);
}

async function playMidiListSimul(midis) {
  const ctx = await ensureAudioReady();
  const now = ctx.currentTime + 0.03;
  for (const midi of midis) {
    const base = nearestSampleMidi(midi);
    const buf = sampleBuffers.get(base);
    if (!buf) continue;
    playBufferNote(ctx, buf, rateForMidi(midi, base), now, 1.0, 0.9);
  }
}

async function playMidiListArp(midis) {
  const ctx = await ensureAudioReady();
  const now = ctx.currentTime + 0.03;
  const step = 0.18;
  for (let i = 0; i < midis.length; i++) {
    const midi = midis[i];
    const base = nearestSampleMidi(midi);
    const buf = sampleBuffers.get(base);
    if (!buf) continue;
    playBufferNote(ctx, buf, rateForMidi(midi, base), now + i * step, 0.75, 0.9);
  }
}

/* ===================== UI HELPERS ===================== */
const statusEl = document.getElementById("status");
const bigAnswerEl = document.getElementById("bigAnswer");
const userAnswerTextEl = document.getElementById("userAnswerText");
const userAnswerMarkEl = document.getElementById("userAnswerMark");
const correctAnswerTextEl = document.getElementById("correctAnswerText");

function setBigAnswer(text) { bigAnswerEl.textContent = text || ""; }
function setResult(userText, correctText, isCorrect) {
  userAnswerTextEl.textContent = userText;
  correctAnswerTextEl.textContent = correctText;
  userAnswerMarkEl.classList.remove("ok","bad","neutral");
  if (isCorrect === true) { userAnswerMarkEl.textContent = "âœ…"; userAnswerMarkEl.classList.add("ok"); }
  else if (isCorrect === false) { userAnswerMarkEl.textContent = "âŒ"; userAnswerMarkEl.classList.add("bad"); }
  else { userAnswerMarkEl.textContent = "â€”"; userAnswerMarkEl.classList.add("neutral"); }
}
function clearResult() { setResult("â€”","â€”",null); setBigAnswer(""); }

/* ===================== MODE + STATS STATE ===================== */
const accAllEl = document.getElementById("accAll");
const accThirdsEl = document.getElementById("accThirds");
const accTriadsEl = document.getElementById("accTriads");
const streakNowEl = document.getElementById("streakNow");
const streakBestEl = document.getElementById("streakBest");
const avgTimeAllEl = document.getElementById("avgTimeAll");
const resetStatsBtn = document.getElementById("resetStatsBtn");
const triadDegreeStatsBody = document.getElementById("triadDegreeStatsBody");

const playBtn = document.getElementById("playBtn");
const replayBtn = document.getElementById("replayBtn");
const majorBtn = document.getElementById("majorBtn");
const minorBtn = document.getElementById("minorBtn");

const asChordChk = document.getElementById("asChord");
const randomStyleChk = document.getElementById("randomStyle");
const diatonicCThirdsOnlyChk = document.getElementById("diatonicCThirdsOnly");
const triadsDegreeModeChk = document.getElementById("triadsDegreeMode");
const commonProgressionsChk = document.getElementById("commonProgressions");

const adaptiveTrainerChk = document.getElementById("adaptiveTrainer");
const adaptiveRow = document.getElementById("adaptiveRow");
const adaptiveSlider = document.getElementById("adaptiveSlider");
const adaptivePct = document.getElementById("adaptivePct");

const biasRow = document.getElementById("biasRow");
const biasSlider = document.getElementById("biasSlider");
const biasPct = document.getElementById("biasPct");

const lowNote = document.getElementById("lowNote");
const highNote = document.getElementById("highNote");
const rangeLabel = document.getElementById("rangeLabel");
const avoidBlackRoot = document.getElementById("avoidBlackRoot");

const thirdsAnswerRow = document.getElementById("thirdsAnswerRow");
const degreeAnswerRow = document.getElementById("degreeAnswerRow");
const degreeButtons = document.getElementById("degreeButtons");

const playModeRow = document.getElementById("playModeRow");
const playModeToggleBtn = document.getElementById("playModeToggleBtn");
const playModeKeyBtn = document.getElementById("playModeKeyBtn");
const playModeKeyHint = document.getElementById("playModeKeyHint");
const playModeKeyHint2 = document.getElementById("playModeKeyHint2");

const stats = {
  all: { correct: 0, total: 0, timeSum: 0, timeCount: 0 },
  thirds: { correct: 0, total: 0, timeSum: 0, timeCount: 0 },
  triads: { correct: 0, total: 0, timeSum: 0, timeCount: 0 },
  streakNow: 0,
  streakBest: 0,
  triadsByDegree: Array.from({length: 8}, () => ({ asked: 0, correct: 0 })),
};

function pct(c,t){ return t===0 ? "â€”" : (Math.round((c/t)*100) + "% ("+c+"/"+t+")"); }
function avgSec(sum,cnt){ return cnt===0 ? "â€”" : (sum/cnt).toFixed(2)+"s"; }
function pctShort(c,t){ return t===0 ? "â€”" : (Math.round((c/t)*100) + "%"); }

function getBiasP() { return Math.max(0, Math.min(1, Number(biasSlider.value) / 100)); }
function updateBiasLabel() { biasPct.textContent = String(biasSlider.value) + "%"; }

function getAdaptiveP() { return Math.max(0, Math.min(1, Number(adaptiveSlider.value) / 100)); }
function updateAdaptiveLabel() { adaptivePct.textContent = String(adaptiveSlider.value) + "%"; }

function updateExtraUIVisibility() {
  biasRow.style.display = (triadsDegreeModeChk.checked && commonProgressionsChk.checked) ? "block" : "none";
  adaptiveRow.style.display = (triadsDegreeModeChk.checked && adaptiveTrainerChk.checked) ? "block" : "none";
  playModeRow.style.display = triadsDegreeModeChk.checked ? "block" : "none";
}
biasSlider.addEventListener("input", () => updateBiasLabel());
adaptiveSlider.addEventListener("input", () => updateAdaptiveLabel());
commonProgressionsChk.addEventListener("change", () => updateExtraUIVisibility());
adaptiveTrainerChk.addEventListener("change", () => updateExtraUIVisibility());
updateBiasLabel();
updateAdaptiveLabel();

function chooseChordNow() {
  if (randomStyleChk.checked) return Math.random() < 0.5;
  return asChordChk.checked;
}
function toggleAsChord() {
  asChordChk.checked = !asChordChk.checked;
  statusEl.textContent = asChordChk.checked ? "××¦×‘ × ×’×™× ×”: ××§×•×¨×“ (×‘×•Ö¾×–×× ×™×ª)" : "××¦×‘ × ×’×™× ×”: ××¨×¤×’'×™×•";
}

const NOTE = { C:60, D:62, E:64, F:65, G:67, A:69, B:71 };

const TRIADS_DEGREES = [
  { degree: 1, roman: "I",     midis: [NOTE.C, NOTE.E, NOTE.G] },
  { degree: 2, roman: "ii",    midis: [NOTE.D, NOTE.F, NOTE.A] },
  { degree: 3, roman: "iii",   midis: [NOTE.E, NOTE.G, NOTE.B] },
  { degree: 4, roman: "IV",    midis: [NOTE.F, NOTE.A, NOTE.C+12] },
  { degree: 5, roman: "V",     midis: [NOTE.G, NOTE.B, NOTE.D+12] },
  { degree: 6, roman: "vi",    midis: [NOTE.A, NOTE.C+12, NOTE.E+12] },
  { degree: 7, roman: "viiÂ°",  midis: [NOTE.B, NOTE.D+12, NOTE.F+12] },
];

const C_THIRDS = [
  { midis: [NOTE.C, NOTE.E],     quality: "maj" },
  { midis: [NOTE.D, NOTE.F],     quality: "min" },
  { midis: [NOTE.E, NOTE.G],     quality: "min" },
  { midis: [NOTE.F, NOTE.A],     quality: "maj" },
  { midis: [NOTE.G, NOTE.B],     quality: "maj" },
  { midis: [NOTE.A, NOTE.C+12],  quality: "min" },
  { midis: [NOTE.B, NOTE.D+12],  quality: "min" },
];

function romanForDegree(d){
  return TRIADS_DEGREES.find(x => x.degree === d)?.roman || String(d);
}

function renderTriadsDegreeStats() {
  let html = "";
  for (let d = 1; d <= 7; d++) {
    const a = stats.triadsByDegree[d].asked;
    const c = stats.triadsByDegree[d].correct;
    html += "<tr><td>"+d+"</td><td>"+romanForDegree(d)+"</td><td>"+a+"</td><td>"+c+"</td><td>"+pctShort(c,a)+"</td></tr>";
  }
  triadDegreeStatsBody.innerHTML = html;
}

function updateStatsUI() {
  accAllEl.textContent = pct(stats.all.correct, stats.all.total);
  accThirdsEl.textContent = pct(stats.thirds.correct, stats.thirds.total);
  accTriadsEl.textContent = pct(stats.triads.correct, stats.triads.total);
  streakNowEl.textContent = String(stats.streakNow);
  streakBestEl.textContent = String(stats.streakBest);
  avgTimeAllEl.textContent = avgSec(stats.all.timeSum, stats.all.timeCount);
  renderTriadsDegreeStats();
}

function record(mode, isCorrect, rt) {
  stats.all.total += 1;
  stats[mode].total += 1;
  if (isCorrect) { stats.all.correct += 1; stats[mode].correct += 1; }

  if (isCorrect) {
    stats.streakNow += 1;
    if (stats.streakNow > stats.streakBest) stats.streakBest = stats.streakNow;
  } else {
    stats.streakNow = 0;
  }

  if (typeof rt === "number" && isFinite(rt) && rt >= 0) {
    stats.all.timeSum += rt; stats.all.timeCount += 1;
    stats[mode].timeSum += rt; stats[mode].timeCount += 1;
  }
}

resetStatsBtn.addEventListener("click", () => {
  stats.all = { correct:0,total:0,timeSum:0,timeCount:0 };
  stats.thirds = { correct:0,total:0,timeSum:0,timeCount:0 };
  stats.triads = { correct:0,total:0,timeSum:0,timeCount:0 };
  stats.streakNow = 0;
  stats.streakBest = 0;
  stats.triadsByDegree = Array.from({length: 8}, () => ({ asked: 0, correct: 0 }));
  updateStatsUI();
});

/* ===================== Q/P PLAY MODE ===================== */
let triadPlayMode = false;           // on/off
let playModeKey = "KeyP";            // default P (changed from Q)
const playModeKeyMap = { KeyP: "P", KeyQ: "Q" };

function updatePlayModeUI() {
  playModeToggleBtn.textContent = triadPlayMode ? "××¦×‘ × ×’×Ÿ ×“×¨×’×•×ª: ×¤×¢×™×œ" : "××¦×‘ × ×’×Ÿ ×“×¨×’×•×ª: ×›×‘×•×™";
  playModeKeyBtn.textContent = "××§×© ××¦×‘: " + playModeKeyMap[playModeKey];
  playModeKeyHint.textContent = playModeKeyMap[playModeKey];
  playModeKeyHint2.textContent = playModeKeyMap[playModeKey];
}

function setTriadPlayMode(on) {
  triadPlayMode = on;
  updatePlayModeUI();
  statusEl.textContent = triadPlayMode
    ? ("××¦×‘ × ×’×Ÿ ×“×¨×’×•×ª ×¤×¢×™×œ ("+playModeKeyMap[playModeKey]+"): J K L ; U I O ×™× ×’×Ÿ ×˜×¨×™××“×•×ª.")
    : ("××¦×‘ × ×’×Ÿ ×“×¨×’×•×ª ×›×‘×•×™ ("+playModeKeyMap[playModeKey]+").");
}

function togglePlayModeKey() {
  playModeKey = (playModeKey === "KeyP") ? "KeyQ" : "KeyP";
  updatePlayModeUI();
  statusEl.textContent = "××§×© ××¦×‘ × ×’×Ÿ ×“×¨×’×•×ª ×¢×•×“×›×Ÿ ×œ-" + playModeKeyMap[playModeKey] + ".";
}

playModeToggleBtn.addEventListener("click", () => {
  if (!triadsDegreeModeChk.checked) return;
  setTriadPlayMode(!triadPlayMode);
});
playModeKeyBtn.addEventListener("click", () => {
  if (!triadsDegreeModeChk.checked) return;
  togglePlayModeKey();
});

/* ===================== TRIADS / THIRDS UI ===================== */
function showTriadsDegreeUI(on) {
  thirdsAnswerRow.style.display = on ? "none" : "block";
  degreeAnswerRow.style.display = on ? "block" : "none";
}
showTriadsDegreeUI(triadsDegreeModeChk.checked);
updateExtraUIVisibility();

/* Degree buttons */
function buildDegreeButtons() {
  degreeButtons.innerHTML = "";
  for (let d = 1; d <= 7; d++) {
    const btn = document.createElement("button");
    btn.textContent = String(d);
    btn.dataset.degree = String(d);
    btn.disabled = true;
    btn.addEventListener("click", () => answerDegree(d));
    degreeButtons.appendChild(btn);
  }
}
buildDegreeButtons();

function enableDegreeButtons(enabled) {
  degreeButtons.querySelectorAll("button").forEach(b => b.disabled = !enabled);
}

triadsDegreeModeChk.addEventListener("change", () => {
  showTriadsDegreeUI(triadsDegreeModeChk.checked);
  updateExtraUIVisibility();
  if (!triadsDegreeModeChk.checked) {
    triadPlayMode = false;
  }
  updatePlayModeUI();
});

/* ===================== SELECTION LOGIC ===================== */
let q = {
  midis:null, correctQuality:null, correctDegree:null, correctRoman:null,
  questionStart:null,
  locked:false
};
let lastDegree = null;

const TRANSITIONS = {
  1: [[5,6],[4,3],[6,2],[2,2],[1,1],[3,1]],
  2: [[5,6],[7,2],[4,2],[1,1],[6,1]],
  3: [[6,4],[4,2],[2,1],[5,1],[1,1]],
  4: [[5,6],[1,4],[2,2],[6,1],[7,1]],
  5: [[1,10],[6,3],[4,1],[7,1],[2,1]],
  6: [[2,4],[4,3],[5,3],[1,2],[7,1]],
  7: [[1,10],[6,2],[5,1]],
};

function weightedChoice(pairs){
  const total = pairs.reduce((s, [_,w]) => s+w, 0);
  let r = Math.random() * total;
  for(const [val, w] of pairs){
    r -= w;
    if(r <= 0) return val;
  }
  return pairs[pairs.length-1][0];
}
function uniformDegree(){ return 1 + Math.floor(Math.random()*7); }

function weightedProgressionNext(prev){
  if(prev == null) return weightedChoice([[1,6],[6,3],[4,2],[2,1],[5,1],[3,1],[7,1]]);
  return weightedChoice(TRANSITIONS[prev] || [[1,1],[5,1],[6,1],[4,1],[2,1],[3,1],[7,1]]);
}

function pickWeakDegreeAdaptive() {
  const pairs = [];
  for (let d = 1; d <= 7; d++) {
    const a = stats.triadsByDegree[d].asked;
    const c = stats.triadsByDegree[d].correct;
    const acc = (c + 1) / (a + 2);
    const weakness = 1 - acc;
    const explore = Math.sqrt(1 / (a + 1));
    const w = weakness + 0.35 * explore + 0.05;
    pairs.push([d, w]);
  }
  return weightedChoice(pairs);
}

function chooseDegree(prev){
  let degree;
  if(commonProgressionsChk.checked){
    const pProg = getBiasP();
    degree = (Math.random() < pProg) ? weightedProgressionNext(prev) : uniformDegree();
  } else {
    degree = uniformDegree();
  }

  if(adaptiveTrainerChk.checked){
    const pA = getAdaptiveP();
    if (Math.random() < pA) degree = pickWeakDegreeAdaptive();
  }
  return degree;
}

async function playCurrent(){
  if(!q.midis) return;
  const chord = chooseChordNow();
  if(chord) await playMidiListSimul(q.midis);
  else await playMidiListArp(q.midis);
  statusEl.textContent = triadsDegreeModeChk.checked ? "×©××¢ â†’ ××™×–×• ×“×¨×’×” ×–×”? (Iâ€“viiÂ°)" : "×©××¢ â†’ ×¢× ×” ××–'×•×¨/××™× ×•×¨.";
}

async function newRound(){
  clearResult();
  q.questionStart = performance.now();
  q.locked = false;

  if(triadsDegreeModeChk.checked){
    const degree = chooseDegree(lastDegree);
    lastDegree = degree;

    const t = TRIADS_DEGREES.find(x => x.degree === degree);
    q.midis = t.midis;
    q.correctDegree = t.degree;
    q.correctRoman = t.roman;
    q.correctQuality = null;

    enableDegreeButtons(true);
    majorBtn.disabled = true;
    minorBtn.disabled = true;
  } else {
    lastDegree = null;
    q.correctDegree = null;
    q.correctRoman = null;

    if(diatonicCThirdsOnlyChk.checked){
      const p = C_THIRDS[Math.floor(Math.random()*C_THIRDS.length)];
      q.midis = p.midis;
      q.correctQuality = p.quality;
    } else {
      const root = pickRandomRoot(Number(lowNote.value), Number(highNote.value), avoidBlackRoot.checked);
      const isMaj = Math.random() < 0.5;
      q.midis = [root, root + (isMaj ? 4 : 3)];
      q.correctQuality = isMaj ? "maj" : "min";
    }

    majorBtn.disabled = false;
    minorBtn.disabled = false;
    enableDegreeButtons(false);
  }

  await playCurrent();
}

async function replayOrStart(){
  if(!q.midis){ await newRound(); return; }
  await playCurrent();
}

function qualityHeb(q){ return q==="maj" ? "××–'×•×¨" : "××™× ×•×¨"; }

function lockAfterAnswer() {
  q.locked = true;
  majorBtn.disabled = true;
  minorBtn.disabled = true;
  enableDegreeButtons(false);
}

function answerQuality(guessQ){
  if(q.locked) return;
  if(!q.correctQuality) return;

  const correct = (guessQ === q.correctQuality);
  setResult(qualityHeb(guessQ), qualityHeb(q.correctQuality), correct);
  setBigAnswer(qualityHeb(q.correctQuality));
  statusEl.textContent = correct ? "âœ… × ×›×•×Ÿ" : "âŒ ×œ× × ×›×•×Ÿ";

  const rt = (performance.now() - q.questionStart) / 1000;
  record("thirds", correct, rt);
  updateStatsUI();
  lockAfterAnswer();
}

function answerDegree(d){
  if(q.locked) return;
  if(q.correctDegree == null) return;

  const correct = (d === q.correctDegree);
  const userRoman = romanForDegree(d);
  const correctRoman = q.correctRoman || romanForDegree(q.correctDegree);

  setResult(userRoman, correctRoman, correct);
  setBigAnswer(correctRoman);
  statusEl.textContent = correct ? "âœ… × ×›×•×Ÿ" : "âŒ ×œ× × ×›×•×Ÿ";

  stats.triadsByDegree[q.correctDegree].asked += 1;
  if (correct) stats.triadsByDegree[q.correctDegree].correct += 1;

  const rt = (performance.now() - q.questionStart) / 1000;
  record("triads", correct, rt);
  updateStatsUI();
  lockAfterAnswer();
}

playBtn.addEventListener("click", newRound);
replayBtn.addEventListener("click", replayOrStart);
majorBtn.addEventListener("click", ()=>answerQuality("maj"));
minorBtn.addEventListener("click", ()=>answerQuality("min"));

/* Reference */
const refC4Btn = document.getElementById("refC4Btn");
function playRef(){
  if(triadsDegreeModeChk.checked){
    const chord = chooseChordNow();
    const triad = [60,64,67];
    if(chord) playMidiListSimul(triad); else playMidiListArp(triad);
    statusEl.textContent = "×¨×¤×¨× ×¡: I (×“×• ××–'×•×¨)";
  } else {
    playSingleMidi(60);
    statusEl.textContent = "×¨×¤×¨× ×¡: ×“×•4";
  }
}
refC4Btn.addEventListener("click", playRef);

/* Play triad by key (JKL;UIO) */
function playTriadByDegreeKey(code) {
  let deg = null;
  if (code === "KeyJ") deg = 1;
  else if (code === "KeyK") deg = 2;
  else if (code === "KeyL") deg = 3;
  else if (code === "Semicolon") deg = 4;
  else if (code === "KeyU") deg = 5;
  else if (code === "KeyI") deg = 6;
  else if (code === "KeyO") deg = 7;
  if (deg == null) return false;

  const t = TRIADS_DEGREES.find(x => x.degree === deg);
  if (!t) return false;

  const chord = chooseChordNow();
  if (chord) playMidiListSimul(t.midis);
  else playMidiListArp(t.midis);

  statusEl.textContent = chord
    ? ("× ×•×’×Ÿ: " + romanForDegree(deg) + " (×‘×•Ö¾×–×× ×™×ª)")
    : ("× ×•×’×Ÿ: " + romanForDegree(deg) + " (××¨×¤×’'×™×•)");
  return true;
}

/* Keyboard shortcuts */
window.addEventListener("keydown", (e)=>{
  if(e.metaKey||e.ctrlKey||e.altKey) return;
  const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
  if (tag === "input" || tag === "textarea" || tag === "select") return;

  // Toggle play-mode by selected key (default P)
  if (e.code === playModeKey && triadsDegreeModeChk.checked) {
    e.preventDefault();
    setTriadPlayMode(!triadPlayMode);
    return;
  }

  // If play-mode is ON and triads mode is ON, JKL;UIO should PLAY, not ANSWER
  if (triadsDegreeModeChk.checked && triadPlayMode) {
    const played = playTriadByDegreeKey(e.code);
    if (played) {
      e.preventDefault();
      return;
    }
    // do not answer in play-mode
  }

  // E toggle chord mode
  if (e.code === "KeyE" || e.key === "e" || e.key === "E" || e.key === "×§") {
    e.preventDefault();
    toggleAsChord();
    return;
  }

  // C reference
  if (e.code === "KeyC" || e.key === "c" || e.key === "C" || e.key === "×‘") {
    e.preventDefault();
    playRef();
    return;
  }

  // play/replay
  if(e.code === "Space"){ e.preventDefault(); newRound(); return; }
  if(e.code === "KeyR"){ e.preventDefault(); replayOrStart(); return; }

  // triads-degree answers (only if NOT in play-mode)
  if(triadsDegreeModeChk.checked && !triadPlayMode){
    let d = null;
    if(e.code === "KeyJ") d = 1;
    else if(e.code === "KeyK") d = 2;
    else if(e.code === "KeyL") d = 3;
    else if(e.code === "Semicolon") d = 4;
    else if(e.code === "KeyU") d = 5;
    else if(e.code === "KeyI") d = 6;
    else if(e.code === "KeyO") d = 7;

    if(d !== null){
      e.preventDefault();
      answerDegree(d);
      return;
    }
    return;
  }

  // thirds answers
  if(!triadsDegreeModeChk.checked){
    if(e.code === "KeyM" || e.code === "KeyF"){ e.preventDefault(); answerQuality("maj"); return; }
    if(e.code === "KeyN" || e.code === "KeyD"){ e.preventDefault(); answerQuality("min"); return; }
  }
});

/* Init */
updateExtraUIVisibility();
updateStatsUI();
updatePlayModeUI();
setTriadPlayMode(false);
</script>

</body>
</html>